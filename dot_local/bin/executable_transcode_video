#!/usr/bin/env python3
"""
Transcode video files to H.265/HEVC 1080p MP4 using HandBrakeCLI.

Moves files to ~/Videos for transcoding, then moves them back.
Supports resume on failure, batch processing, and recursive scanning.
"""

import hashlib
import json
import os
import shutil
import subprocess
import sys
import time
from pathlib import Path
from typing import Optional, List, Dict

from j_lib import JParser


# Constants â€” all work happens under ~/Videos regardless of cwd
WORKING_DIR = Path.home() / "Videos"
RESUME_FILE = WORKING_DIR / ".transcode_resume.json"
VIDEO_EXTENSIONS = {
    '.mkv', '.avi', '.mp4', '.mov', '.wmv', '.flv', '.webm',
    '.m4v', '.mpg', '.mpeg', '.ts', '.m2ts', '.vob', '.3gp', '.ogv'
}


class TranscodeState:
    """Tracks the state of a transcoding operation."""

    NOT_STARTED = "not_started"
    MOVED_TO_WORKING = "moved_to_working"
    ENCODING_COMPLETE = "encoding_complete"
    COMPLETE = "complete"

    STATE_DESCRIPTIONS = {
        NOT_STARTED: "Ready to move file to working directory",
        MOVED_TO_WORKING: "Ready to begin transcoding",
        ENCODING_COMPLETE: "Ready to move transcoded file back",
        COMPLETE: "Complete"
    }

    def __init__(self, original_path: str, state: str = NOT_STARTED):
        self.original_path = Path(original_path).resolve()
        self.original_name = self.original_path.name
        self.original_stem = self.original_path.stem
        self.original_dir = self.original_path.parent

        # Generate unique ID based on original path
        self.operation_id = hashlib.md5(str(self.original_path).encode()).hexdigest()[:12]

        # Working directory paths
        self.working_copy = WORKING_DIR / self.original_name
        self.output_mp4 = WORKING_DIR / f"{self.original_stem}.mp4"
        self.final_path = self.original_dir / f"{self.original_stem}.mp4"

        self.state = state

    def save(self):
        """Save state to resume file."""
        operations = self._load_all_operations()

        operations[self.operation_id] = {
            "original_path": str(self.original_path),
            "original_name": self.original_name,
            "original_stem": self.original_stem,
            "original_dir": str(self.original_dir),
            "working_copy": str(self.working_copy),
            "output_mp4": str(self.output_mp4),
            "final_path": str(self.final_path),
            "state": self.state
        }

        with open(RESUME_FILE, 'w') as f:
            json.dump(operations, f, indent=2)
        print(f"[STATE] Saved state (operation: {self.operation_id})")

    @classmethod
    def _load_all_operations(cls) -> Dict:
        """Load all operations from resume file."""
        if not RESUME_FILE.exists():
            return {}

        try:
            with open(RESUME_FILE, 'r') as f:
                return json.load(f)
        except Exception as e:
            print(f"[ERROR] Failed to load resume file: {e}")
            return {}

    @classmethod
    def load_for_path(cls, original_path: str) -> Optional['TranscodeState']:
        """Load state for a specific video path."""
        operations = cls._load_all_operations()

        temp_state = cls(original_path)
        operation_id = temp_state.operation_id

        if operation_id not in operations:
            return None

        data = operations[operation_id]
        state_obj = cls(data["original_path"], data["state"])
        return state_obj

    @classmethod
    def list_all(cls) -> List['TranscodeState']:
        """List all resumable operations."""
        operations = cls._load_all_operations()
        result = []

        for op_id, data in operations.items():
            if data["state"] != cls.COMPLETE:
                state_obj = cls(data["original_path"], data["state"])
                result.append(state_obj)

        return result

    def remove(self):
        """Remove this operation from resume file."""
        operations = self._load_all_operations()
        if self.operation_id in operations:
            del operations[self.operation_id]

            if operations:
                with open(RESUME_FILE, 'w') as f:
                    json.dump(operations, f, indent=2)
            else:
                if RESUME_FILE.exists():
                    RESUME_FILE.unlink()

            print(f"[STATE] Cleared operation {self.operation_id}")


class BatchTranscodeState:
    """Tracks the state of a batch transcoding operation for a directory."""

    BATCH_FILE = WORKING_DIR / ".transcode_batch.json"

    def __init__(self, source_dir: str):
        self.source_dir = Path(source_dir).resolve()
        self.batch_id = hashlib.md5(str(self.source_dir).encode()).hexdigest()[:12]
        self.pending_files: List[str] = []
        self.completed_files: List[str] = []
        self.current_file: Optional[str] = None

    def discover_videos(self):
        """Find all video files in the source directory."""
        videos = []
        for f in self.source_dir.iterdir():
            if f.is_file() and f.suffix.lower() in VIDEO_EXTENSIONS:
                videos.append(f.name)
        videos.sort()
        return videos

    def save(self):
        """Save batch state to file."""
        batches = self._load_all_batches()
        batches[self.batch_id] = {
            "source_dir": str(self.source_dir),
            "pending_files": self.pending_files,
            "completed_files": self.completed_files,
            "current_file": self.current_file
        }
        with open(self.BATCH_FILE, 'w') as f:
            json.dump(batches, f, indent=2)
        print(f"[BATCH] Saved batch state (batch: {self.batch_id})")

    @classmethod
    def _load_all_batches(cls) -> Dict:
        """Load all batch operations from file."""
        if not cls.BATCH_FILE.exists():
            return {}
        try:
            with open(cls.BATCH_FILE, 'r') as f:
                return json.load(f)
        except Exception as e:
            print(f"[ERROR] Failed to load batch file: {e}")
            return {}

    @classmethod
    def load_for_dir(cls, source_dir: str) -> Optional['BatchTranscodeState']:
        """Load batch state for a specific directory."""
        batches = cls._load_all_batches()
        temp = cls(source_dir)
        if temp.batch_id not in batches:
            return None
        data = batches[temp.batch_id]
        state = cls(data["source_dir"])
        state.pending_files = data["pending_files"]
        state.completed_files = data["completed_files"]
        state.current_file = data["current_file"]
        return state

    @classmethod
    def list_all(cls) -> List['BatchTranscodeState']:
        """List all incomplete batch operations."""
        batches = cls._load_all_batches()
        result = []
        for batch_id, data in batches.items():
            if data["pending_files"] or data["current_file"]:
                state = cls(data["source_dir"])
                state.pending_files = data["pending_files"]
                state.completed_files = data["completed_files"]
                state.current_file = data["current_file"]
                result.append(state)
        return result

    def remove(self):
        """Remove this batch from the batch file."""
        batches = self._load_all_batches()
        if self.batch_id in batches:
            del batches[self.batch_id]
            if batches:
                with open(self.BATCH_FILE, 'w') as f:
                    json.dump(batches, f, indent=2)
            else:
                if self.BATCH_FILE.exists():
                    self.BATCH_FILE.unlink()
            print(f"[BATCH] Cleared batch {self.batch_id}")

    def get_next_file(self) -> Optional[Path]:
        """Get the next file to process."""
        if self.current_file:
            return self.source_dir / self.current_file
        if self.pending_files:
            self.current_file = self.pending_files.pop(0)
            return self.source_dir / self.current_file
        return None

    def mark_current_complete(self):
        """Mark the current file as completed."""
        if self.current_file:
            self.completed_files.append(self.current_file)
            self.current_file = None

    def files_remaining(self) -> int:
        """Return count of files still to process."""
        count = len(self.pending_files)
        if self.current_file:
            count += 1
        return count

    def total_files(self) -> int:
        """Return total file count."""
        return len(self.pending_files) + len(self.completed_files) + (1 if self.current_file else 0)


class ScanState:
    """Tracks directories that have been scanned for transcoding."""

    SCAN_FILE = WORKING_DIR / ".transcode_scan.json"

    def __init__(self):
        self.complete_dirs: Dict[str, Dict] = {}
        self.last_full_scan: Optional[str] = None

    def save(self):
        """Save scan state to file."""
        data = {
            "last_full_scan": self.last_full_scan,
            "complete_dirs": self.complete_dirs
        }
        with open(self.SCAN_FILE, 'w') as f:
            json.dump(data, f, indent=2)

    @classmethod
    def load(cls) -> 'ScanState':
        """Load scan state from file."""
        state = cls()
        if not cls.SCAN_FILE.exists():
            return state

        try:
            with open(cls.SCAN_FILE, 'r') as f:
                data = json.load(f)
                state.last_full_scan = data.get("last_full_scan")
                state.complete_dirs = data.get("complete_dirs", {})
        except Exception as e:
            print(f"[WARN] Failed to load scan state: {e}")

        return state

    def is_dir_complete(self, dir_path: Path) -> bool:
        """Check if a directory is marked complete and unchanged."""
        dir_str = str(dir_path.resolve())
        if dir_str not in self.complete_dirs:
            return False

        try:
            current_mtime = dir_path.stat().st_mtime
            saved_mtime = self.complete_dirs[dir_str].get("mtime", 0)
            return current_mtime == saved_mtime
        except OSError:
            return False

    def mark_dir_complete(self, dir_path: Path):
        """Mark a directory as complete (all videos are .mp4)."""
        dir_str = str(dir_path.resolve())
        try:
            mtime = dir_path.stat().st_mtime
            self.complete_dirs[dir_str] = {
                "mtime": mtime,
                "scanned_at": time.strftime("%Y-%m-%dT%H:%M:%S")
            }
        except OSError as e:
            print(f"[WARN] Could not get mtime for {dir_path}: {e}")

    def unmark_dir(self, dir_path: Path):
        """Remove a directory from the complete list."""
        dir_str = str(dir_path.resolve())
        if dir_str in self.complete_dirs:
            del self.complete_dirs[dir_str]


class NVENCSessionLimitError(Exception):
    """Raised when NVENC session limit is reached."""
    pass


def check_handbrake():
    """Check if HandBrakeCLI is installed."""
    try:
        result = subprocess.run(
            ["HandBrakeCLI", "--version"],
            capture_output=True,
            text=True,
            timeout=5
        )
        if result.returncode == 0:
            print(f"[CHECK] HandBrakeCLI found: {result.stdout.split()[0]}")
            return True
    except (subprocess.TimeoutExpired, FileNotFoundError):
        pass

    print("[ERROR] HandBrakeCLI not found. Please install HandBrake CLI.")
    print("Install: sudo apt install handbrake-cli  (Debian/Ubuntu)")
    print("     or: sudo dnf install handbrake-cli  (Fedora)")
    return False


def move_file_with_progress(src: Path, dst: Path):
    """Move file and show progress."""
    src = Path(src)
    dst = Path(dst)

    if not src.exists():
        raise FileNotFoundError(f"Source file not found: {src}")

    file_size = src.stat().st_size
    file_size_mb = file_size / (1024 * 1024)

    print(f"[MOVE] {src} -> {dst}")
    print(f"[MOVE] File size: {file_size_mb:.2f} MB")

    try:
        src_stat = os.stat(src)
        dst_parent_stat = os.stat(dst.parent)
        same_device = src_stat.st_dev == dst_parent_stat.st_dev
    except:
        same_device = False

    if same_device:
        print(f"[MOVE] Same filesystem detected - moving instantly...")
        os.rename(src, dst)
        print(f"[MOVE] Complete!")
    else:
        print(f"[MOVE] Copying across filesystems...")

        bytes_copied = 0
        start_time = time.time()
        chunk_size = 1024 * 1024

        with open(src, 'rb') as src_file:
            with open(dst, 'wb') as dst_file:
                while True:
                    chunk = src_file.read(chunk_size)
                    if not chunk:
                        break

                    dst_file.write(chunk)
                    bytes_copied += len(chunk)

                    percent = (bytes_copied / file_size) * 100
                    elapsed = time.time() - start_time

                    if elapsed > 0:
                        speed_mbps = (bytes_copied / (1024 * 1024)) / elapsed
                        mb_copied = bytes_copied / (1024 * 1024)

                        print(f"\r[MOVE] Progress: {percent:.1f}% ({mb_copied:.1f}/{file_size_mb:.1f} MB) @ {speed_mbps:.2f} MB/s", end='', flush=True)

        print()

        shutil.copystat(src, dst)

        max_retries = 3
        for attempt in range(max_retries):
            try:
                result = subprocess.run(
                    ["rm", "-f", str(src)],
                    capture_output=True,
                    text=True,
                    timeout=30
                )
                if result.returncode != 0:
                    raise OSError(f"rm -f failed: {result.stderr.strip()}")
                if src.exists():
                    raise OSError(f"File still exists after rm -f: {src}")
                break
            except (OSError, subprocess.TimeoutExpired) as e:
                if attempt < max_retries - 1:
                    print(f"\n[MOVE] Warning: Failed to delete source (attempt {attempt + 1}/{max_retries}): {e}")
                    print(f"[MOVE] Retrying in 2 seconds...")
                    time.sleep(2)
                else:
                    raise OSError(f"Failed to delete source file after {max_retries} attempts: {src}. Error: {e}")

        print(f"[MOVE] Complete!")


def transcode_with_handbrake(input_path: Path, output_path: Path):
    """Run HandBrakeCLI to transcode video."""
    print(f"\n[ENCODE] Starting HandBrake transcoding...")
    print(f"[ENCODE] Input:  {input_path}")
    print(f"[ENCODE] Output: {output_path}")
    print(f"[ENCODE] Encoder: NVIDIA NVENC H.265 (Hardware Accelerated)")
    print(f"[ENCODE] Format: MP4 (H.265/HEVC)\n")

    cmd = [
        "HandBrakeCLI",
        "-i", str(input_path),
        "-o", str(output_path),
        "--encoder", "nvenc_h265",
        "--encoder-preset", "medium",
        "--quality", "23",
        "--maxHeight", "1080",
        "--maxWidth", "1920",
        "--format", "av_mp4",
        "--aencoder", "av_aac",
        "--ab", "160"
    ]

    try:
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=1,
            universal_newlines=True
        )

        output_lines = []
        nvenc_session_error = False

        for line in process.stdout:
            print(line, end='')
            output_lines.append(line.lower())

            if any(keyword in line.lower() for keyword in [
                "nvenc_open_encode_session_ex failed",
                "cannot open nvenc codec",
                "too many concurrent sessions",
                "encoder busy"
            ]):
                nvenc_session_error = True

        process.wait()

        if process.returncode != 0:
            if nvenc_session_error:
                raise NVENCSessionLimitError(
                    "NVENC encoder session limit reached. "
                    "Wait for other encoding tasks to complete or reduce concurrent transcodes."
                )
            raise subprocess.CalledProcessError(process.returncode, cmd)

        print(f"\n[ENCODE] Transcoding complete!")

    except subprocess.CalledProcessError as e:
        print(f"\n[ERROR] HandBrake failed with return code {e.returncode}")
        raise


def cleanup_partial_files(state: TranscodeState):
    """Clean up partial output files on failure."""
    if state.output_mp4.exists():
        print(f"[CLEANUP] Removing partial output: {state.output_mp4}")
        state.output_mp4.unlink()


def scan_for_videos(root_path: Path, force: bool = False) -> tuple[List[Path], ScanState]:
    """Recursively scan for non-MP4 video files that need transcoding."""
    root_path = root_path.resolve()

    if force:
        scan_state = ScanState()
        print("[SCAN] Force mode: ignoring cached directory states")
    else:
        scan_state = ScanState.load()

    videos_to_transcode: List[Path] = []
    dirs_scanned = 0
    dirs_skipped = 0

    print(f"\n[SCAN] Scanning: {root_path}")
    print(f"[SCAN] Looking for non-MP4 video files...\n")

    for dirpath, dirnames, filenames in os.walk(root_path):
        current_dir = Path(dirpath)

        if not force and scan_state.is_dir_complete(current_dir):
            dirs_skipped += 1
            continue

        dirs_scanned += 1

        video_files = []
        non_mp4_videos = []

        for filename in filenames:
            file_path = current_dir / filename
            suffix = file_path.suffix.lower()

            if suffix in VIDEO_EXTENSIONS:
                video_files.append(file_path)
                if suffix != '.mp4':
                    non_mp4_videos.append(file_path)

        if non_mp4_videos:
            for video in non_mp4_videos:
                print(f"[SCAN] Found: {video}")
                videos_to_transcode.append(video)
            scan_state.unmark_dir(current_dir)
        elif video_files:
            scan_state.mark_dir_complete(current_dir)

    scan_state.last_full_scan = time.strftime("%Y-%m-%dT%H:%M:%S")
    scan_state.save()

    print(f"\n[SCAN] Directories scanned: {dirs_scanned}")
    print(f"[SCAN] Directories skipped (cached): {dirs_skipped}")
    print(f"[SCAN] Videos found needing transcoding: {len(videos_to_transcode)}")

    return videos_to_transcode, scan_state


def scan_and_transcode(root_path: Path, force: bool = False) -> int:
    """Scan for videos and transcode them."""
    videos, scan_state = scan_for_videos(root_path, force)

    if not videos:
        print("\n" + "="*70)
        print("ALL VIDEOS TRANSCODED")
        print("="*70)
        print("\nNo non-MP4 video files found that need transcoding.")
        print(f"Scanned root: {root_path}")
        print("="*70 + "\n")
        return 0

    dirs_to_videos: Dict[Path, List[Path]] = {}
    for video in videos:
        parent = video.parent
        if parent not in dirs_to_videos:
            dirs_to_videos[parent] = []
        dirs_to_videos[parent].append(video)

    sorted_dirs = sorted(dirs_to_videos.keys())

    print("\n" + "="*70)
    print("SCAN COMPLETE - STARTING TRANSCODING")
    print("="*70)
    print(f"\nTotal files to transcode: {len(videos)}")
    print(f"Across {len(sorted_dirs)} directories")
    print("="*70 + "\n")

    total_processed = 0
    total_failed = 0

    for dir_idx, directory in enumerate(sorted_dirs, 1):
        dir_videos = sorted(dirs_to_videos[directory])

        print("\n" + "#"*70)
        print(f"# DIRECTORY {dir_idx}/{len(sorted_dirs)}: {directory}")
        print("#"*70)

        dir_success = True

        for vid_idx, video_path in enumerate(dir_videos, 1):
            print(f"\n[FILE {vid_idx}/{len(dir_videos)}] {video_path.name}")

            success = process_single_file(video_path)

            if success:
                total_processed += 1
            else:
                total_failed += 1
                dir_success = False
                print(f"\n[ERROR] Failed to transcode: {video_path}")
                print("[INFO] Continuing with next file...")

        if dir_success:
            scan_state.mark_dir_complete(directory)
            scan_state.save()
            print(f"\n[SCAN] Marked directory complete: {directory}")

    print("\n" + "="*70)
    print("SCAN TRANSCODING COMPLETE")
    print("="*70)
    print(f"\nSuccessfully transcoded: {total_processed} files")
    if total_failed:
        print(f"Failed: {total_failed} files")
    print(f"Original files kept in: {WORKING_DIR}")
    print("="*70 + "\n")

    return 0 if total_failed == 0 else 1


def list_and_select_batch() -> Optional[BatchTranscodeState]:
    """List all resumable batch operations and let user select one."""
    batches = BatchTranscodeState.list_all()

    if not batches:
        print("\n" + "="*70)
        print("NO RESUMABLE OPERATIONS")
        print("="*70)
        print("\nThere are no incomplete batch transcoding operations to resume.")
        print("\nUsage:")
        print("  transcode_video <video_directory>")
        print("\nExample:")
        print("  transcode_video /path/to/videos/")
        print("="*70 + "\n")
        return None

    print("\n" + "="*70)
    print("RESUMABLE BATCH OPERATIONS")
    print("="*70)
    print(f"\nFound {len(batches)} incomplete batch(es):\n")

    for idx, batch in enumerate(batches, 1):
        print(f"[{idx}] {batch.source_dir}")
        print(f"    Completed: {len(batch.completed_files)}/{batch.total_files()} files")
        if batch.current_file:
            print(f"    In progress: {batch.current_file}")
        print(f"    Remaining: {batch.files_remaining()} files")
        print()

    print("="*70)
    print("\nSelect a batch to resume (1-{}) or 'q' to quit:".format(len(batches)))

    while True:
        response = input("Choice: ").strip().lower()

        if response == 'q' or response == 'quit':
            print("Exiting.")
            return None

        try:
            choice = int(response)
            if 1 <= choice <= len(batches):
                return batches[choice - 1]
            else:
                print(f"Invalid choice. Please enter a number between 1 and {len(batches)}, or 'q' to quit.")
        except ValueError:
            print("Invalid input. Please enter a number or 'q' to quit.")


def process_single_file(video_path: Path) -> bool:
    """Process a single video file through the transcode pipeline."""
    existing_state = TranscodeState.load_for_path(str(video_path))
    if existing_state:
        state = existing_state
        print(f"\n[RESUME] Continuing file from state: {state.state}\n")
    else:
        state = TranscodeState(str(video_path))

    try:
        if state.state == TranscodeState.NOT_STARTED:
            print("\n" + "="*70)
            print("STAGE 1: MOVING FILE TO WORKING DIRECTORY")
            print("="*70 + "\n")

            if not state.original_path.exists():
                raise FileNotFoundError(f"Video file not found: {state.original_path}")

            move_file_with_progress(state.original_path, state.working_copy)
            state.state = TranscodeState.MOVED_TO_WORKING
            state.save()

        if state.state == TranscodeState.MOVED_TO_WORKING:
            print("\n" + "="*70)
            print("STAGE 2: TRANSCODING VIDEO")
            print("="*70 + "\n")

            if not state.working_copy.exists():
                raise FileNotFoundError(f"Working copy not found: {state.working_copy}")

            transcode_with_handbrake(state.working_copy, state.output_mp4)
            state.state = TranscodeState.ENCODING_COMPLETE
            state.save()

        if state.state == TranscodeState.ENCODING_COMPLETE:
            print("\n" + "="*70)
            print("STAGE 3: MOVING TRANSCODED FILE BACK")
            print("="*70 + "\n")

            if not state.output_mp4.exists():
                raise FileNotFoundError(f"Output file not found: {state.output_mp4}")

            move_file_with_progress(state.output_mp4, state.final_path)
            state.state = TranscodeState.COMPLETE
            state.save()

        print("\n" + "="*70)
        print("FILE COMPLETE!")
        print("="*70)
        print(f"\nOriginal file: {state.working_copy}")
        print(f"  (kept in working directory)")
        print(f"\nTranscoded file: {state.final_path}")
        print(f"  (H.265/HEVC MP4 format)")
        print("="*70 + "\n")

        state.remove()
        return True

    except NVENCSessionLimitError as e:
        print(f"\n[ERROR] NVENC Session Limit: {e}")
        print("\nNVIDIA consumer GPUs typically support 2-3 concurrent encode sessions.")
        print("Wait for other transcoding tasks to complete before retrying.")
        state.save()
        return False

    except Exception as e:
        print(f"\n[ERROR] Operation failed: {e}")
        cleanup_partial_files(state)
        state.save()
        return False


def prompt_batch_resume(batch: BatchTranscodeState) -> bool:
    """Prompt user whether to resume from saved batch state."""
    print("\n" + "="*70)
    print("BATCH RESUME DETECTED")
    print("="*70)
    print(f"Found previous batch for: {batch.source_dir}")
    print(f"Completed: {len(batch.completed_files)}/{batch.total_files()} files")
    if batch.current_file:
        print(f"In progress: {batch.current_file}")
    print(f"Remaining: {batch.files_remaining()} files")
    print("\nDo you want to resume from this state?")
    print("  [y] Yes, resume from saved state")
    print("  [n] No, start fresh (will delete saved state for this batch)")
    print("="*70)

    while True:
        response = input("Choice [y/n]: ").strip().lower()
        if response in ['y', 'yes']:
            return True
        elif response in ['n', 'no']:
            return False
        else:
            print("Invalid input. Please enter 'y' or 'n'.")


def main():
    parser = JParser(
        description="Transcode videos to H.265 1080p MP4 using HandBrakeCLI. "
                    "Run without arguments to see resumable operations."
    )
    parser.add_argument(
        "video_dir",
        nargs='?',
        help="Path to directory containing video files to transcode"
    )
    parser.add_argument(
        "--scan",
        metavar="ROOT_PATH",
        help="Recursively scan ROOT_PATH for non-MP4 videos and transcode them"
    )
    parser.add_argument(
        "--force",
        action="store_true",
        help="Force full rescan, ignoring cached directory states (use with --scan)"
    )
    args = parser.run()

    # Ensure ~/Videos exists
    WORKING_DIR.mkdir(parents=True, exist_ok=True)

    if not check_handbrake():
        return 1

    if args.scan:
        scan_root = Path(args.scan).resolve()

        if not scan_root.exists():
            print(f"[ERROR] Scan path not found: {scan_root}")
            return 1

        if not scan_root.is_dir():
            print(f"[ERROR] Scan path is not a directory: {scan_root}")
            return 1

        return scan_and_transcode(scan_root, args.force)

    if args.force:
        print("[WARN] --force flag is only used with --scan mode, ignoring")

    if not args.video_dir:
        batch = list_and_select_batch()
        if not batch:
            return 0
        print(f"\n[RESUME] Continuing batch from: {batch.source_dir}\n")
    else:
        video_dir = Path(args.video_dir).resolve()

        if not video_dir.exists():
            print(f"[ERROR] Directory not found: {video_dir}")
            return 1

        if not video_dir.is_dir():
            print(f"[ERROR] Path is not a directory: {video_dir}")
            return 1

        existing_batch = BatchTranscodeState.load_for_dir(str(video_dir))
        if existing_batch:
            if prompt_batch_resume(existing_batch):
                batch = existing_batch
                print(f"\n[RESUME] Continuing batch\n")
            else:
                existing_batch.remove()
                batch = BatchTranscodeState(str(video_dir))
                batch.pending_files = batch.discover_videos()
        else:
            batch = BatchTranscodeState(str(video_dir))
            batch.pending_files = batch.discover_videos()

        if not batch.pending_files and not batch.current_file:
            print(f"\n[ERROR] No video files found in: {video_dir}")
            print(f"Supported extensions: {', '.join(sorted(VIDEO_EXTENSIONS))}")
            return 1

    print("\n" + "="*70)
    print("BATCH TRANSCODING")
    print("="*70)
    print(f"Source directory: {batch.source_dir}")
    print(f"Total files: {batch.total_files()}")
    print(f"Completed: {len(batch.completed_files)}")
    print(f"Remaining: {batch.files_remaining()}")
    print("="*70 + "\n")

    batch.save()

    while True:
        next_file = batch.get_next_file()
        if not next_file:
            break

        file_num = len(batch.completed_files) + 1
        total = batch.total_files()

        print("\n" + "#"*70)
        print(f"# FILE {file_num}/{total}: {next_file.name}")
        print("#"*70)

        batch.save()

        success = process_single_file(next_file)

        if success:
            batch.mark_current_complete()
            batch.save()
        else:
            print(f"\n[ERROR] Failed to process: {next_file.name}")
            print(f"\nBatch progress saved. Run again to resume.")
            print(f"  Completed: {len(batch.completed_files)}/{batch.total_files()} files")
            return 1

    print("\n" + "="*70)
    print("BATCH COMPLETE!")
    print("="*70)
    print(f"\nSuccessfully transcoded {len(batch.completed_files)} file(s)")
    print(f"Source directory: {batch.source_dir}")
    print(f"\nOriginal files kept in: {WORKING_DIR}")
    print("="*70 + "\n")

    batch.remove()
    return 0


if __name__ == "__main__":
    sys.exit(main())
