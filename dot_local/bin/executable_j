#!/usr/bin/env python3
"""Quick launcher for custom scripts in ~/.local/bin/.

Uses fzf to fuzzy-find from a curated list with descriptions, then
introspects the selected script's arguments via --_j_meta and walks
the user through required and optional args interactively.
"""

import json
import os
import readline
import shlex
import subprocess
import sys
from pathlib import Path

# ── History ────────────────────────────────────────────────────────────
HISTORY_DIR = Path(
    os.environ.get("XDG_STATE_HOME", Path.home() / ".local" / "state")
) / "j"
HISTORY_FILE = HISTORY_DIR / "history.json"


def load_history() -> dict:
    """Load per-script arg history from disk."""
    try:
        return json.loads(HISTORY_FILE.read_text())
    except (FileNotFoundError, json.JSONDecodeError):
        return {}


def save_history(history: dict):
    """Persist per-script arg history to disk."""
    HISTORY_DIR.mkdir(parents=True, exist_ok=True)
    HISTORY_FILE.write_text(json.dumps(history, indent=2))


# ── ANSI helpers ──────────────────────────────────────────────────────
BOLD = "\033[1m"
CYAN = "\033[36m"
DIM = "\033[2m"
YELLOW = "\033[33m"
GREEN = "\033[32m"
RESET = "\033[0m"

# ── Script registry ───────────────────────────────────────────────────
# Format: "command_name:Short description"
SCRIPTS = [
    "camera_toggle:Camera viewer — show/toggle eufy camera streams",
    "copy_album:Copy audio files by album using metadata tags",
    "convert_webp:Convert WebP images to other formats",
    "dmps:Monitor power control via DDC/CI",
    "download_tidal:Download music from TIDAL (CLI wrapper)",
    "eufy_2fa:Enter Eufy 2FA verification code",
    "fp:Find and print full path via fzf",
    "ga:Git add with fuzzy matching",
    "gco:Git checkout file with fuzzy matching",
    "install_ags_deps:Install AGS v2 and Astal dependencies",
    "playlist:Create M3U playlists using beets",
    "rsync_upload:Upload files via rsync with bandwidth control",
    "transcode_video:Transcode videos to H.265 1080p MP4 via HandBrake",
    "v:Open file in nvim by fuzzy name match",
    "weather:Display weather via rustormy",
]

# Scripts NOT in the j picker (still work standalone):
# Hyprland — launched by exec-once, keybinds, or portals:
#   cycle_windows, doorbell_popup, fix_layout, hypr_zoom, hypr_zoomd,
#   save_layout, screenshare_picker, start_ags, startup_layout
# AGS internals — called programmatically by the shell:
#   clipboard_history, list_recent_files, list_wallpapers, perplexity_chat
# Git aliases — invoked as `git wt` / `git wtr`:
#   git-wt, git-wtr


def fzf_select() -> str | None:
    """Show fzf picker and return the selected script name."""
    # Build aligned display: pad name column to max width
    entries = []
    max_name = 0
    for entry in SCRIPTS:
        name, desc = entry.split(":", 1)
        max_name = max(max_name, len(name))
        entries.append((name, desc))

    lines = [f"{name:<{max_name}}  {desc}" for name, desc in entries]
    display = "\n".join(lines)

    try:
        result = subprocess.run(
            ["fzf", "--prompt=script> ", "--height=~50%", "--reverse"],
            input=display,
            capture_output=True,
            text=True,
        )
    except FileNotFoundError:
        print("fzf not found", file=sys.stderr)
        sys.exit(1)

    if result.returncode != 0 or not result.stdout.strip():
        return None

    # Extract the script name (first whitespace-delimited token)
    return result.stdout.strip().split()[0]


def get_meta(script: str) -> dict | None:
    """Run script --_j_meta and return parsed JSON, or None."""
    try:
        result = subprocess.run(
            [script, "--_j_meta"],
            capture_output=True,
            text=True,
            timeout=3,
        )
        if result.returncode == 0 and result.stdout.strip():
            return json.loads(result.stdout)
    except (subprocess.TimeoutExpired, json.JSONDecodeError, FileNotFoundError):
        pass
    return None


def enable_path_completion():
    """Enable readline tab-completion for file paths."""
    readline.set_completer_delims(" \t\n")
    readline.parse_and_bind("tab: complete")

    def path_completer(text, state):
        # Expand ~ and find matches
        expanded = os.path.expanduser(text)
        parent = Path(expanded).parent if expanded else Path(".")
        prefix = Path(expanded).name if expanded else ""

        try:
            matches = []
            search_dir = parent if parent.is_dir() else Path(".")
            for p in search_dir.iterdir():
                name = str(p) if text.startswith(("/", "~")) else p.name
                # Rebuild relative to what the user typed
                if parent != Path("."):
                    candidate = str(parent / p.name)
                else:
                    candidate = p.name
                if candidate.startswith(expanded) or p.name.startswith(prefix):
                    if p.is_dir():
                        candidate += "/"
                    matches.append(candidate)
            matches.sort()
            return matches[state] if state < len(matches) else None
        except (OSError, IndexError):
            return None

    readline.set_completer(path_completer)


def prompt_value(label: str, help_text: str, default=None, choices=None) -> str:
    """Prompt for a single value with optional default and choices."""
    if choices:
        # Numbered choice selection
        print(f"  {CYAN}{label}{RESET} — {help_text}")
        for i, c in enumerate(choices, 1):
            marker = f" {DIM}(default){RESET}" if str(c) == str(default) else ""
            print(f"    {YELLOW}{i}{RESET}) {c}{marker}")
        while True:
            suffix = f" [default: {default}]" if default is not None else ""
            raw = input(f"    choose{suffix}: ").strip()
            if not raw and default is not None:
                return str(default)
            try:
                idx = int(raw)
                if 1 <= idx <= len(choices):
                    return str(choices[idx - 1])
            except ValueError:
                if raw in [str(c) for c in choices]:
                    return raw
            print(f"    {DIM}pick 1-{len(choices)} or type a value{RESET}")
    else:
        suffix = f" [{DIM}default: {default}{RESET}]" if default is not None else ""
        prompt_str = f"  {CYAN}{label}{RESET} ({help_text}){suffix}: "
        val = input(prompt_str).strip()
        return val if val else (str(default) if default is not None else "")


def prompt_flag(label: str, help_text: str, prev: bool = False) -> bool:
    """Prompt for a boolean flag, with optional previous-value default."""
    if prev:
        hint = f"{YELLOW}Y/n{RESET}"
    else:
        hint = f"{YELLOW}y/N{RESET}"
    raw = input(f"  {CYAN}{label}{RESET}  {help_text} [{hint}]: ").strip()
    if not raw:
        return prev
    return raw.lower() in ("y", "yes")


def interactive_args(meta: dict, prev: dict | None = None) -> tuple[list[str], dict]:
    """Walk user through args from --_j_meta JSON.

    Returns (argv_list, values_dict) where values_dict maps arg names
    to their chosen values for history storage.
    """
    args_spec = meta.get("args", [])
    if not args_spec:
        return [], {}

    prev = prev or {}
    positional = [a for a in args_spec if a["positional"] and a["required"]]
    optional_pos = [a for a in args_spec if a["positional"] and not a["required"]]
    optional_flags = [a for a in args_spec if not a["positional"]]

    result_positional = []
    result_optional = []
    values = {}  # for history

    has_prev = bool(prev)
    enable_path_completion()

    # Show previous invocation if available
    if has_prev:
        print(f"  {DIM}(previous args remembered — press Enter to reuse){RESET}")

    # ── Required positional args ──
    if positional:
        print(f"\n  {BOLD}Required:{RESET}")
        for arg in positional:
            # Use previous value as default if available
            prev_val = prev.get(arg["name"])
            default = prev_val if prev_val is not None else None
            while True:
                val = prompt_value(
                    arg["name"], arg["help"],
                    default=default, choices=arg["choices"],
                )
                if val:
                    result_positional.append(val)
                    values[arg["name"]] = val
                    break
                print(f"    {DIM}(required){RESET}")

    # ── Optional positional args ──
    if optional_pos:
        print(f"\n  {BOLD}Optional positional:{RESET}")
        for arg in optional_pos:
            prev_val = prev.get(arg["name"])
            default = prev_val if prev_val is not None else arg["default"]
            val = prompt_value(
                arg["name"], arg["help"],
                default=default, choices=arg["choices"],
            )
            if val:
                result_positional.append(val)
                values[arg["name"]] = val

    # ── Optional flags/options ──
    if optional_flags:
        # Check if any flags were set previously
        prev_flags_set = any(prev.get(a["name"]) for a in optional_flags)
        flag_count = len(optional_flags)

        if prev_flags_set:
            hint = f"{YELLOW}Y/n{RESET}"
            prompt_text = (
                f"\n  {BOLD}{flag_count} option{'s' if flag_count != 1 else ''}"
                f" available{RESET} {DIM}(some set previously){RESET}."
                f" Configure? [{hint}]: "
            )
        else:
            hint = f"{YELLOW}y/N{RESET}"
            prompt_text = (
                f"\n  {BOLD}{flag_count} option{'s' if flag_count != 1 else ''}"
                f" available.{RESET} Configure? [{hint}]: "
            )

        raw = input(prompt_text).strip()
        show_options = raw.lower() in ("y", "yes") if raw else prev_flags_set

        if show_options:
            for arg in optional_flags:
                flag = arg["flags"][0] if arg["flags"] else f"--{arg['name']}"
                prev_val = prev.get(arg["name"])
                if arg["is_flag"]:
                    was_set = bool(prev_val)
                    if prompt_flag(flag, arg["help"], prev=was_set):
                        result_optional.append(flag)
                        values[arg["name"]] = True
                    else:
                        values[arg["name"]] = False
                else:
                    default = prev_val if prev_val is not None else arg["default"]
                    val = prompt_value(
                        flag, arg["help"],
                        default=default, choices=arg["choices"],
                    )
                    if val and val != str(arg["default"]):
                        result_optional.append(flag)
                        result_optional.append(val)
                        values[arg["name"]] = val
                    else:
                        values[arg["name"]] = None

    return result_positional + result_optional, values


def main():
    selected = fzf_select()
    if not selected:
        return

    # If j was called with extra args, pass them through directly
    if len(sys.argv) > 1:
        os.execvp(selected, [selected] + sys.argv[1:])

    # Try to get script metadata for interactive prompts
    meta = get_meta(selected)
    history = load_history()
    prev = history.get(selected)

    if meta:
        desc = meta.get("description", "")
        if desc:
            print(f"\n  {BOLD}{CYAN}{selected}{RESET} — {desc}")

        argv, values = interactive_args(meta, prev)

        # Save to history
        history[selected] = values
        save_history(history)
    else:
        # Fallback: plain text prompt
        raw = input(f"  args (Enter to skip): ").strip()
        argv = shlex.split(raw) if raw else []

    # Show the command we're about to run
    if argv:
        cmd_display = " ".join(shlex.quote(a) for a in argv)
        print(f"\n  {DIM}→ {selected} {cmd_display}{RESET}\n")
    else:
        print()

    os.execvp(selected, [selected] + argv)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print()
